<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="viewRepresentation">
<entry key="jsNamespace" type="xstring" value="grouped_bar_chart_namespace"/>
<config key="jsCode">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="/* global knimeService:false, d3:false, kt:false, nv:false */%%00010(grouped_bar_chart_namespace = function () {%%00010%%00010    var barchart = {};%%00010    var layoutContainer;%%00010    var MIN_HEIGHT = 100, MIN_WIDTH = 100;%%00010    var _representation, _value;%%00010    var chart, svg;%%00010    var knimeTable;%%00010%%00010    var plotData;%%00010    var wrapedPlotData;%%00010    var colorRange;%%00010    var categories;%%00010    var freqCols;%%00010    var _translator;%%00010    var _keyNameMap;%%00010    var _incomingTable;%%00010%%00010    /**%%00010%%00009 * 2d-array where for each category (indexing follows categories array) we%%00010%%00009 * store an array of those frequency columns, which have a missing value in%%00010%%00009 * the current category. This allows to exclude specific bars or even the%%00010%%00009 * whole category. Storing by category helps to group warnings also by%%00010%%00009 * category. Required for missing values handling.%%00010%%00009 */%%00010    var missValInCat;%%00010%%00010    /**%%00010%%00009 * Array where for each frequency column, which has in all other categories%%00010%%00009 * only missing values, we store whether it has a value in the Missing%%00010%%00009 * values category. This allows to decide, if we should keep this freq%%00010%%00009 * column (if it has a value in MissValCat and the option &quot;include%%00010%%00009 * MissValCat&quot; is on) or exclude it. Each item has the fields: col - name of%%00010%%00009 * freq column hasValueOnMissValCat - whether the column has a non-missing%%00010%%00009 * value in the Missing values category (true/false) Required for missing%%00010%%00009 * values handling.%%00010%%00009 */%%00010    var freqColValueOnMissValCat;%%00010%%00010    /**%%00010%%00009 * Array where for each frequency column, which has non-missing value in the%%00010%%00009 * Missing values category, we store this value. We need to store it%%00010%%00009 * separately to quickly add/remove them to the plot data, when the option%%00010%%00009 * &quot;include MissValCat&quot; is getting switched. Each item has the fields: col -%%00010%%00009 * name of freq column value - non-missing value, this freq column has in%%00010%%00009 * the Missing values category Required for missing values handling.%%00010%%00009 */%%00010    var missValCatValues;%%00010%%00010    /**%%00010%%00009 * Boolean flag - is the Missing values category present in the dataset.%%00010%%00009 * Required for missing values handling.%%00010%%00009 */%%00010    var isMissValCat;%%00010%%00010    /**%%00010%%00009 * Map where keys - frequency column names, values - array of those%%00010%%00009 * categories for which the bar, specified by the corresponding freq column%%00010%%00009 * and the category, was excluded from the view. There excluded bars%%00010%%00009 * actually specify those dummy null values, we have to add to the stacked%%00010%%00009 * chart to fix it. Choosing freq cols as keys helps adding dummy nulls%%00010%%00009 * since the plot dataset has to be key-&gt;values. Required for missing values%%00010%%00009 * handling.%%00010%%00009 */%%00010    var excludeFreqColCatMap;%%00010    %%00010    var showWarnings;%%00010%%00010    var MISSING_VALUES_LABEL = 'Missing values';%%00010    var MISSING_VALUES_ONLY = 'missingValuesOnly';%%00010    var FREQ_COLUMN_MISSING_VALUES_ONLY = 'freqColumnMissingValuesOnly';%%00010    var CATEGORY_MISSING_VALUES_ONLY = 'categoryMissingValuesOnly';%%00010    var NO_DATA_AVAILABLE = 'noDataAvailable';%%00010%%00010    barchart.init = function (representation, value) {%%00010        _value = value;%%00010        _representation = representation;%%00010        _incomingTable = _representation.inObjects[0].table;%%00010%%00010        if (_representation.options.enableSelection &amp;&amp; _representation.inObjects[0].translator) {%%00010        %%00009_translator = _representation.inObjects[0].translator;%%00010        %%00009_translator.sourceID = _representation.inObjects[0].uuid;%%00010        %%00009_translator.targetIDs = [_representation.tableIds[0]];%%00010        %%00009knimeService.registerSelectionTranslator(_translator, _translator.sourceID);%%00010        %%00009subscribeToSelection(_value.options.subscribeToSelection);%%00010        }%%00010        %%00010        showWarnings = _representation.options.showWarnings;%%00010%%00010        if (_representation.warnMessage &amp;&amp; showWarnings) {%%00010            knimeService.setWarningMessage(_representation.warnMessage);%%00010        }%%00010        if (_representation.options.enableViewControls) {%%00010            drawControls();%%00010        }%%00010        drawChart();%%00010%%00010        _keyNameMap = new KeyNameMap(getClusterToRowMapping());%%00010    };%%00010    %%00010%%00010    function drawChart(redraw) {%%00010%%00010        d3.select('html').style('width', '100%').style('height', '100%');%%00010        d3.select('body').style('width', '100%').style('height', '100%');%%00010        /*%%00010%%00009%%00009 * Process options%%00010%%00009%%00009 */%%00010        var viewControls = _representation.options.enableViewControls;%%00010        var optWidth = _representation.options['width'];%%00010        var optHeight = _representation.options['height'];%%00010%%00010        var optTitle = _value.options['title'];%%00010        var optSubtitle = _value.options['subtitle'];%%00010        var optCatLabel = _value.options['catLabel'];%%00010        var optFreqLabel = _value.options['freqLabel'];%%00010%%00010        var sortLabels = _representation.options['sort'];%%00010        var optStaggerLabels = _value.options['staggerLabels'];%%00010        var optLegend = _representation.options['legend'];%%00010        var optTooltips = _representation.options['tooltip'];%%00010%%00010        var optOrientation = _value.options['orientation'];%%00010%%00010        var optFullscreen = _representation.options['svg']['fullscreen'] &amp;&amp; _representation.runningInView;%%00010        var optWidth = _representation.options['svg']['width'];%%00010        var optHeight = _representation.options['svg']['height'];%%00010        var optEnableSelection = _representation.options['enableSelection'];%%00010%%00010        var isTitle = optTitle || optSubtitle;%%00010%%00010        var body = d3.select('body');%%00010%%00010        var width = optWidth + 'px';%%00010        var height = optHeight + 'px';%%00010        if (optFullscreen) {%%00010            knimeService.floatingHeader(isTitle);%%00010            width = '100%';%%00010            height = (isTitle) ? '100%' : 'calc(100% - ' + knimeService.headerHeight() + 'px)';%%00010        }%%00010%%00010        var div;%%00010        if (redraw) {%%00010            d3.select('svg').remove();%%00010            div = d3.select('#svgContainer');%%00010        } else {%%00010            layoutContainer = body.append('div')%%00010                .attr('id', 'layoutContainer')%%00010                .attr('class', 'knime-layout-container')%%00010                .style('width', width)%%00010                .style('height', height)%%00010                .style('min-width', MIN_WIDTH + 'px')%%00010                .style('min-height', MIN_HEIGHT + 'px');%%00010%%00010            div = layoutContainer.append('div')%%00010                .attr('id', 'svgContainer')%%00010                .attr('class', 'knime-svg-container')%%00010                .style('min-width', MIN_WIDTH + 'px')%%00010                .style('min-height', MIN_HEIGHT + 'px');%%00010        }%%00010%%00010        var svg1 = document.createElementNS('http://www.w3.org/2000/svg', 'svg');%%00010        div[0][0].appendChild(svg1);%%00010%%00010        svg = d3.select('svg')%%00010            .style('display', 'block')%%00010            .classed('colored', true);%%00010        %%00010        %%00010        // handle clicks on background to deselect current selection%%00010        if(optEnableSelection) {%%00010%%00009        svg.on(&quot;click&quot;, function() {%%00010%%00009        %%00009removeHilightBar(&quot;&quot;, true);%%00010%%00009        %%00009_value.options['selection'] = [];%%00010%%00009        %%00009publishSelection(true);%%00010%%00009        });%%00010        }%%00010        %%00010%%00010        if (!optFullscreen) {%%00010            if (optWidth &gt; 0) {%%00010                div.style('width', optWidth + 'px');%%00010                svg.attr('width', optWidth);%%00010                // Looks like the below doesn't work,%%00010                // above does work...%%00010                // chart.width(optWidth);%%00010            }%%00010            if (optHeight &gt; 0) {%%00010                svg.attr('height', optHeight);%%00010                div.style('height', optHeight + 'px');%%00010                // Looks like the below doesn't work,%%00010                // above does work...%%00010                // chart.height(optHeight);%%00010            }%%00010        } else {%%00010            // Set full screen height/width%%00010            div.style('width', '100%');%%00010            div.style('height', height /*TODO: this should be 100% always, but for some reason that doesn't work*/);%%00010%%00010            svg.attr('width', '100%');%%00010            svg.attr('height', '100%');%%00010        }%%00010%%00010        if (!redraw) {%%00010            /*%%00010%%00009%%00009%%00009 * Process data%%00010%%00009%%00009%%00009 */%%00010            knimeTable = new kt();%%00010            // Add the data from the input port to the knimeTable.%%00010            var port0dataTable = _representation.inObjects[0].table;%%00010            if (!_representation.isHistogram &amp;&amp; sortLabels) {%%00010                port0dataTable.rows = sortByClusterName(port0dataTable.rows);%%00010            }%%00010            knimeTable.setDataTable(port0dataTable);%%00010%%00010            processData();%%00010        }%%00010%%00010        /*%%00010%%00009%%00009 * Plot chart%%00010%%00009%%00009 */%%00010        nv.addGraph(function () {%%00010            if (optOrientation) {%%00010                chart = nv.models.multiBarHorizontalChart();%%00010            } else {%%00010                chart = nv.models.multiBarChart();%%00010                chart.reduceXTicks(!!_representation.isHistogram);%%00010                /*if (_representation.options.rotateLabels) {%%00010                    chart.rotateLabels(_representation.options.rotateLabels);%%00010                }*/%%00010            }%%00010%%00010            chart.dispatch.on('renderEnd.css', function() {%%00010            %%00009setCssClasses();%%00010            });%%00010            // tooltip is re-created every time therefore we need to assign%%00010            // classes accordingly%%00010            chart.multibar.dispatch.on('elementMouseover.tooltipCss', setTooltipCssClasses);%%00010            chart.multibar.dispatch.on('elementMousemove.tooltipCss', setTooltipCssClasses);%%00010            chart.legend.dispatch.on('legendClick', function(series, index) {%%00010            %%00009drawChart(true);%%00010            %%00009d3.event.stopPropagation();%%00010            });%%00010%%00010            var stacked = _value.options.chartType == 'Stacked';%%00010            if (stacked) {%%00010                fixStackedData(true); // add dummy nulls%%00010            }%%00010            chart.stacked(stacked);%%00010%%00010            chart%%00010                .color(colorRange)%%00010                .duration(0)%%00010                .margin({ right: 20 })%%00010                .groupSpacing(_representation.isHistogram ? 0.01 : 0.1);%%00010%%00010            updateTitles(false);%%00010%%00010            chart.showControls(false); // all the controls moved to settings menu%%00010            chart.showLegend(optLegend);%%00010            chart.tooltip.enabled((typeof optTooltips === 'undefined') || optTooltips);%%00010%%00010            updateAxisLabels(false);%%00010            svg.datum(plotData).transition().duration(0).call(chart);%%00010            nv.utils.windowResize(function () { %%00010            %%00009updateAxisLabels(true); %%00010            %%00009updateLabels(); %%00010            %%00009setCssClasses(); %%00010            %%00009removeHilightBar(&quot;&quot;,true);%%00010            %%00009redrawSelection();%%00010        %%00009});%%00010            %%00010            // redraws selection%%00010            if(_value.options['selection']) {%%00010            %%00009redrawSelection();%%00010            }%%00010            return chart;%%00010        });%%00010    }%%00010    %%00010    function sortByClusterName(array) {%%00010        return array.sort(function(a, b) {%%00010            var x = a.data[0];%%00010            var y = b.data[0];%%00010            %%00010            // Make sure, that missing values are displayed last%%00010            if(x == null) {%%00010            %%00009return 1%%00010            } else if (y == null) {%%00010            %%00009return -1;%%00010            }%%00010            %%00010            if (typeof x == &quot;string&quot;)%%00010            {%%00010                x = (&quot;&quot;+x).toLowerCase(); %%00010            }%%00010            if (typeof y == &quot;string&quot;)%%00010            {%%00010                y = (&quot;&quot;+y).toLowerCase();%%00010            }%%00010            return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));%%00010        });%%00010    }%%00010    %%00010    function registerClickHandler () {%%00010    %%00009d3.selectAll(&quot;.nv-bar&quot;).on('click',function(event) {%%00010%%00009%%00009%%00009handleHighlightClick(event);%%00010%%00009%%00009%%00009d3.event.stopPropagation();%%00010    %%00009});%%00010    }%%00010    %%00010    function getActiveBars() {%%00010    %%00009var stacked = _value.options['chartType'];%%00010    %%00009var counter = 0;%%00010    %%00009if(stacked == &quot;Stacked&quot;) {%%00010    %%00009%%00009counter = 1;%%00010    %%00009} else {%%00010    %%00009%%00009for (var j = 0; j &lt; plotData.length; j++) { %%00010    %%00009%%00009%%00009if(plotData[j].disabled !== true) {%%00010    %%00009%%00009%%00009%%00009counter ++;%%00010    %%00009%%00009%%00009} %%00010    %%00009%%00009}%%00010    %%00009}%%00010    %%00009return counter;%%00010    }%%00010%%00010%%00009function redrawSelection() {%%00010%%00009    var length = _value.options['selection'] ? _value.options['selection'].length : 0;%%00010        for (var i = 0; i &lt; length; i++) {%%00010            createHilightBar(_keyNameMap.getNameFromKey(_value.options['selection'][i][0]),%%00010                _value.options['selection'][i][1]);%%00010        }%%00010    }%%00010    %%00010    function subscribeToSelection(subscribeBool) {%%00010        if (_representation.options.enableSelection) {%%00010            if (subscribeBool) {%%00010                knimeService.subscribeToSelection(_translator.sourceID, onSelectionChanged);%%00010            } else {%%00010                knimeService.unsubscribeSelection(_translator.sourceID, onSelectionChanged);%%00010            }%%00010        }%%00010    }%%00010    %%00010    function publishSelection(shouldPublish){%%00010    %%00009if(shouldPublish) {%%00010    %%00009%%00009knimeService.setSelectedRows(_translator.sourceID, getSelectedRowIDs(), onSelectionChanged);%%00010    %%00009}%%00010    }%%00010    %%00010%%00009function checkClearSelectionButton(){%%00010%%00009%%00009if(_value.options['selection']){%%00010%%00009%%00009%%00009var button = d3.select(&quot;#clearSelectionButton&quot;);%%00010%%00009%%00009%%00009if (button){%%00010%%00009%%00009%%00009%%00009button.classed(&quot;inactive&quot;, function(){return !_value.options['selection'].length &gt; 0});%%00010%%00009%%00009%%00009}%%00010%%00009%%00009}%%00010%%00009}%%00010    %%00010    function getSelectedRowIDs() {%%00010    %%00009if(_value.options['selection']) {%%00010%%00009    %%00009var selectedRowIDs = [];%%00010%%00009    %%00009for (var i = 0; i&lt; _value.options['selection'].length; i++) {%%00010%%00009    %%00009%%00009selectedRowIDs.push( _value.options['selection'][i][0]);%%00010%%00009    %%00009}%%00010%%00009    %%00009return selectedRowIDs;%%00010    %%00009} else {%%00010    %%00009%%00009return [];%%00010    %%00009}%%00010    }%%00010    %%00010    function selectCorrectBar(clusterName) {%%00010    %%00009var allBars = d3.selectAll(&quot;.knime-x text.knime-tick-label&quot;);%%00010    %%00009for(var j = 0; j &lt; allBars[0].length; j++) {%%00010    %%00009%%00009if(d3.select(allBars[0][j]).data()[0] == clusterName) {%%00010    %%00009%%00009%%00009return d3.select(allBars[0][j]);%%00010    %%00009%%00009}%%00010    %%00009}%%00010    }%%00010    %%00010    // Removes the clusterName with the given cluster name. If &quot;removeAll&quot; is true all bars are removed%%00010    function removeHilightBar(clusterName, removeAll) {%%00010        if (_value.options['selection']){%%00010            if (removeAll) {%%00010                var length = _value.options['selection'].length;%%00010                for (var i = 0; i &lt; length; i++) {%%00010                    var selectedEntry = _value.options['selection'][i];%%00010                    var bars = d3.selectAll(&quot;.hilightBar&quot;);%%00010                    var barParent = bars.select(function() { return this.parentNode; });%%00010                    barParent.select(&quot;text&quot;).classed(selectedEntry[1], false);%%00010                    d3.selectAll(&quot;.hilightBar&quot;).remove();%%00010                }%%00010            } else {%%00010                var barIndex = getSelectedRowIDs().indexOf(_keyNameMap.getKeyFromName(clusterName));%%00010                if (barIndex &gt; -1) {%%00010                    var selectedEntry = _value.options['selection'][barIndex];%%00010                    var bar = selectCorrectBar(clusterName);%%00010                    if(bar){%%00010                        var barParent = bar.select(function() { return this.parentNode; });%%00010                        barParent.select(&quot;text&quot;).classed(selectedEntry[1], false);%%00010                        barParent.selectAll(&quot;.hilightBar&quot;).remove();%%00010                    }%%00010                }%%00010            }%%00010        }%%00010    } %%00010    %%00010    // Create a hilight-bar above the cluster with the given name and assigns the given css class to it%%00010    function createHilightBar (clusterName, selectionClass) {%%00010    %%00009var optOrientation = _value.options['orientation'];%%00010%%00009  %%00009%%00009for(var k = 0; k &lt; plotData.length; k++) {%%00010%%00009  %%00009%%00009%%00009for(var j = 0; j &lt; plotData[k].values.length; j++) {%%00010%%00009%%00009  %%00009%%00009if(plotData[k].values[j].x === clusterName) {%%00010%%00009%%00009  %%00009%%00009%%00009d3.selectAll(&quot;.knime-x text&quot;).each(function(d,i) {%%00010%%00009%%00009  %%00009%%00009%%00009%%00009if(i==j) {%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009d3.select(this).classed(selectionClass,true);%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009var selectionTitle;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009if(selectionClass == &quot;knime-selected&quot;) {%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009selectionTitle = &quot;Selected&quot;;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009} else {%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009selectionTitle = &quot;Partially selected&quot;;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009}%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009var posX = 0;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009var posY = 0;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009var highlightHeight = 0;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009var highlightWidth = 5;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009if(optOrientation) {%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009posY = -0.5*(d3.select(&quot;.nv-bar.positive&quot;).node().getBBox().height * getActiveBars());%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009posX = -1.5*highlightWidth;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009highlightHeight = (d3.select(&quot;.nv-bar.positive&quot;).node().getBBox().height) * getActiveBars();%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009} else {%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009%%00009posX = -0.5*(d3.select(&quot;.nv-bar.positive&quot;).node().getBBox().width * getActiveBars());%%00010%%00009%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009highlightWidth = (d3.select(&quot;.nv-bar.positive&quot;).node().getBBox().width) * getActiveBars();%%00010%%00009%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009highlightHeight = 5;%%00010%%00009%%00009%%00009  %%00009%%00009%%00009%%00009%%00009%%00009posY = 0.5*highlightHeight;%%00010%%00009%%00009  %%00009%%00009%%00009%%00009%%00009}%%00010%%00009    %%00009  %%00009%%00009%%00009%%00009d3.select(this.parentNode).append(&quot;rect&quot;).classed(&quot;hilightBar&quot;,true)%%00010%%00009    %%00009  %%00009%%00009%%00009%%00009.classed(selectionClass, true)%%00010%%00009    %%00009  %%00009%%00009%%00009%%00009.attr({ x: posX, y: posY, width: highlightWidth, height: highlightHeight})%%00010%%00009    %%00009  %%00009%%00009%%00009%%00009.style('pointer-events', 'all')%%00010%%00009    %%00009  %%00009%%00009%%00009%%00009.append(&quot;title&quot;)%%00010%%00009    %%00009  %%00009%%00009%%00009%%00009.classed('knime-tooltip', true)%%00010%%00009    %%00009  %%00009%%00009%%00009%%00009.text(selectionTitle);%%00010%%00009%%00009  %%00009%%00009%%00009%%00009} %%00010%%00009  %%00009%%00009%%00009%%00009});%%00010%%00009  %%00009%%00009%%00009%%00009j = plotData[k].values.length;%%00010%%00009  %%00009%%00009%%00009%%00009k = plotData.length-1;%%00010%%00009%%00009  %%00009%%00009}%%00010%%00009  %%00009%%00009}%%00010%%00009  %%00009}%%00010    }%%00010    %%00010    function getClusterToRowMapping() {%%00010    %%00009var map = {};%%00010    %%00009for (var i = 0; i &lt; _incomingTable.rows.length; i++) {%%00010    %%00009%%00009if(_incomingTable.rows[i].data[0]) {%%00010    %%00009%%00009%%00009map[_incomingTable.rows[i].data[0]] = _incomingTable.rows[i].rowKey;%%00010    %%00009%%00009} else {%%00010    %%00009%%00009%%00009map[&quot;Missing values&quot;] = _incomingTable.rows[i].rowKey;%%00010    %%00009%%00009}%%00010    %%00009}%%00010    %%00009return map;%%00010    }%%00010    %%00010    // Helper class to handle conversion from cluster name to row key%%00010    function KeyNameMap(map) {%%00010%%00009%%00009   this.map = map;%%00010%%00009%%00009   this.reverseMap = {};%%00010%%00009%%00009   for(var key in map){%%00010%%00009%%00009      var value = map[key];%%00010%%00009%%00009      this.reverseMap[value] = key;   %%00010    %%00009}%%00010    }%%00010%%00009%%00009   %%00010%%00009KeyNameMap.prototype.getKeyFromName = function(name){ %%00010%%00009%%00009return this.map[name]; %%00010%%00009}%%00010%%00009KeyNameMap.prototype.getNameFromKey = function(key){%%00010%%00009%%00009return this.reverseMap[key];%%00010%%00009}%%00010    %%00010    function handleHighlightClick(event) {%%00010    %%00009if(!_value.options['selection']) {%%00010    %%00009%%00009_value.options['selection'] = [];%%00010    %%00009}%%00010    %%00009var clusterName = event.x;%%00010    %%00009var clusterKey = _keyNameMap.getKeyFromName(clusterName);%%00010    %%00009var barIndex = getSelectedRowIDs().indexOf(clusterKey);%%00010    %%00009// Deselect already selected bar when clicking again on it%%00010    %%00009if(barIndex &gt; -1 &amp;&amp; (d3.event.ctrlKey || d3.event.shiftKey || d3.event.metaKey)){%%00010    %%00009%%00009if(_representation.options.enableSelection) {%%00010        %%00009%%00009if(_value.options.publishSelection) {%%00010        %%00009%%00009%%00009knimeService.removeRowsFromSelection(_translator.sourceID,[clusterKey], _translator.sourceID);%%00010        %%00009%%00009}%%00010    %%00009%%00009}%%00010%%00009%%00009%%00009removeHilightBar(clusterName, false);%%00010%%00009%%00009%%00009_value.options['selection'].splice(barIndex, 1);%%00010    %%00009} else if(!d3.event.ctrlKey &amp;&amp; !d3.event.shiftKey &amp;&amp; !d3.event.metaKey) {%%00010    %%00009%%00009// Deselect all previously selected bars and select the newly clicked one%%00010    %%00009%%00009if(_representation.options.enableSelection) {%%00010        %%00009%%00009if(_value.options.publishSelection) {%%00010        %%00009%%00009%%00009knimeService.setSelectedRows(_translator.sourceID,[clusterKey], _translator.sourceID);%%00010        %%00009%%00009}%%00010    %%00009%%00009}%%00010%%00009%%00009%%00009removeHilightBar(clusterName, true);%%00010    %%00009%%00009createHilightBar(clusterName, &quot;knime-selected&quot;);%%00010    %%00009%%00009_value.options['selection'] = [];%%00010    %%00009%%00009_value.options['selection'].push([clusterKey, &quot;knime-selected&quot;]);%%00010    %%00009} else {%%00010    %%00009%%00009// Select the clicked bar, as it is either a new selection or a additional selection%%00010    %%00009%%00009if(_representation.options.enableSelection) {%%00010        %%00009%%00009if(_value.options.publishSelection) {%%00010        %%00009%%00009%%00009knimeService.addRowsToSelection(_translator.sourceID,[clusterKey], _translator.sourceID);%%00010        %%00009%%00009}%%00010    %%00009%%00009}%%00010    %%00009%%00009createHilightBar(clusterName, &quot;knime-selected&quot;);%%00010    %%00009%%00009_value.options['selection'].push([clusterKey, &quot;knime-selected&quot;]);%%00010    %%00009}%%00010    %%00009checkClearSelectionButton();%%00010    }%%00010    %%00010    function onSelectionChanged(data) {%%00010    %%00009if(!_value.options['selection']) {%%00010    %%00009%%00009_value.options['selection'] = [];%%00010    %%00009}%%00010    %%00009if (data.reevaluate) {%%00010    %%00009%%00009removeHilightBar(&quot;&quot;, true);%%00010    %%00009%%00009var selectedRows = knimeService.getAllRowsForSelection(_translator.sourceID);%%00010    %%00009%%00009var partiallySelectedRows = knimeService.getAllPartiallySelectedRows(_translator.sourceID);%%00010    %%00009%%00009for (var selectedRow in selectedRows) {%%00010    %%00009%%00009%%00009var length = _value.options['selection'].length;%%00010    %%00009%%00009%%00009_value.options['selection'][length] = [selectedRows[selectedRow], &quot;knime-selected&quot;];%%00010    %%00009%%00009%%00009createHilightBar(_keyNameMap.getNameFromKey(selectedRows[selectedRow]),%%00010    %%00009%%00009%%00009%%00009%%00009&quot;knime-selected&quot;);%%00010    %%00009%%00009}%%00010    %%00009%%00009for (var partiallySelectedRow in partiallySelectedRows) {%%00010    %%00009%%00009%%00009var length = _value.options['selection'].length;%%00010    %%00009%%00009%%00009_value.options['selection'][length] = [partiallySelectedRows[partiallySelectedRow], &quot;knime-partially-selected&quot;];%%00010    %%00009%%00009%%00009createHilightBar(_keyNameMap.getNameFromKey(partiallySelectedRows[partiallySelectedRow]),%%00010    %%00009%%00009%%00009%%00009%%00009&quot;knime-partially-selected&quot;);%%00010    %%00009%%00009}%%00010        } else if (data.changeSet) {%%00010        %%00009if (data.changeSet.removed) {%%00010        %%00009%%00009data.changeSet.removed.map(function(rowId) {%%00010        %%00009%%00009%%00009var clusterName = rowId;%%00010        %%00009%%00009%%00009var index = getSelectedRowIDs().indexOf(clusterName);%%00010        %%00009%%00009%%00009if (index &gt; -1) {%%00010        %%00009%%00009%%00009%%00009removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);%%00010        %%00009%%00009%%00009%%00009_value.options['selection'].splice(index, 1);%%00010        %%00009%%00009%%00009}%%00010        %%00009%%00009});%%00010        %%00009}%%00010        %%00009if(data.changeSet.partialRemoved) {%%00010        %%00009%%00009data.changeSet.partialRemoved.map(function(rowId) {%%00010        %%00009%%00009%%00009var clusterName = rowId;%%00010        %%00009%%00009%%00009var index = getSelectedRowIDs().indexOf(clusterName);%%00010        %%00009%%00009%%00009if (index &gt; -1) {%%00010        %%00009%%00009%%00009%%00009removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);%%00010        %%00009%%00009%%00009%%00009_value.options['selection'].splice(index, 1);%%00010        %%00009%%00009%%00009}%%00010        %%00009%%00009});%%00010        %%00009}%%00010%%00009        if (data.changeSet.added) {%%00010%%00009            data.changeSet.added.map(function(rowId) {%%00010%%00009                var index = getSelectedRowIDs().indexOf(rowId);%%00010%%00009                if (index === -1) {%%00010%%00009                %%00009_value.options['selection'].push([rowId, &quot;knime-selected&quot;]);%%00010%%00009                %%00009createHilightBar(_keyNameMap.getNameFromKey(rowId), &quot;knime-selected&quot;);%%00010%%00009                }%%00010%%00009            });%%00010%%00009        }%%00010%%00009        if(data.changeSet.partialAdded) {%%00010%%00009        %%00009data.changeSet.partialAdded.map(function(rowId) {%%00010%%00009                var index = getSelectedRowIDs().indexOf(rowId);%%00010%%00009                if (index === -1) {%%00010%%00009                %%00009_value.options['selection'].push([rowId, &quot;knime-partially-selected&quot;]);%%00010%%00009                    createHilightBar(_keyNameMap.getNameFromKey(rowId), &quot;knime-partially-selected&quot;);%%00010%%00009                }%%00010%%00009            });%%00010%%00009        }%%00010%%00009     }%%00010    %%00009checkClearSelectionButton();%%00010    }%%00010%%00010%%00010    processData = function () {%%00010        var optMethod = _representation.options['aggr'];%%00010        var optFreqCol = _representation.options['freq'];%%00010        var optCat = _representation.options['cat'];%%00010%%00010        var customColors, colorScale;%%00010        if (_representation.inObjects[1]) {%%00010            // Custom color scale%%00010            var colorTable = new kt();%%00010            colorTable.setDataTable(_representation.inObjects[1]);%%00010            if (colorTable.getColumnTypes()[0] == 'string') {%%00010                customColors = {};%%00010                var colorCol = colorTable.getColumn(0);%%00010                for (var i = 0; i &lt; colorCol.length; i++) {%%00010                    customColors[colorCol[i]] = colorTable.getRowColors()[i];%%00010                }%%00010                colorScale = [];%%00010            }%%00010        }%%00010%%00010        categories = knimeTable.getColumn(optCat);%%00010        var numCat = categories.length;%%00010%%00010        if (optMethod == 'Occurence\u00A0Count') {%%00010            optFreqCol = [knimeTable.getColumnNames()[1]];%%00010        }%%00010%%00010        // Get the frequency columns%%00010        var valCols = [];%%00010        var isDuplicate = false;%%00010        freqCols = [];%%00010%%00010        for (var k = 0; k &lt; optFreqCol.length; k++) {%%00010            var valCol = knimeTable.getColumn(optFreqCol[k]);%%00010            // ToDo: Add an isDuplicate test here...%%00010            if (isDuplicate != true) {%%00010                valCols.push(valCol);%%00010                freqCols.push(optFreqCol[k]);%%00010            }%%00010        }%%00010%%00010        plotData = [];%%00010        freqColValueOnMissValCat = [];%%00010        missValInCat = new Array(numCat);%%00010        for (var i = 0; i &lt; numCat; i++) {%%00010            missValInCat[i] = [];%%00010        }%%00010        isMissValCat = false;%%00010        missValCatValues = [];%%00010        var numFreqColsNoMissVal = 0; // number of freq columns which have%%00010        // non-missing values (needed for color%%00010        // scale)%%00010        if (valCols.length &gt; 0) {%%00010            var numDataPoints = valCols[0].length;%%00010            for (var j = 0; j &lt; freqCols.length; j++) {%%00010%%00010                var col = freqCols[j];%%00010                if (optMethod == 'Occurence\u00A0Count' &amp;&amp; !_representation.isHistogram) {%%00010                    col = 'Occurrence Count';%%00010                }%%00010                var values = [];%%00010                var onlyMissValInCats = true; // whether the freq col has only%%00010                // missing values in%%00010                // non-&quot;Missing values&quot;%%00010                // categories%%00010                var hasValueOnMissValCat = false; // whether the freq col has%%00010                // a non-missing value in%%00010                // the Missing values%%00010                // category%%00010%%00010                for (var i = 0; i &lt; numDataPoints; i++) {%%00010                    if (categories != undefined) {%%00010                        if (isDuplicate == true) {%%00010                            alert('Duplicate categories found in column.');%%00010                            return 'duplicate';%%00010                        }%%00010%%00010                        var cat = categories[i];%%00010                        var val = valCols[j][i];%%00010%%00010                        if (cat !== null) {%%00010                            if (val !== null) {%%00010                                // if both cat and value are not null - normal%%00010                                // case, just add the value%%00010                                onlyMissValInCats = false;%%00010                                values.push({%%00010                                    'x': cat,%%00010                                    'y': val%%00010                                });%%00010                            }%%00010                        } else {%%00010                            // Missing values category%%00010                            isMissValCat = true;%%00010                            if (val !== null) {%%00010                                // save the non-missing value for the%%00010                                // corresponding freq col%%00010                                missValCatValues.push({%%00010                                    'col': col,%%00010                                    'value': val%%00010                                });%%00010                                // this freq col has non-missing value in the%%00010                                // Missing value category%%00010                                hasValueOnMissValCat = true;%%00010                            }%%00010                        }%%00010%%00010                        if (val === null) {%%00010                            // this freq col has a missing value in the current%%00010                            // category - save this info%%00010                            missValInCat[i].push(col);%%00010                        }%%00010                    }%%00010                }%%00010%%00010                if (!onlyMissValInCats) {%%00010                    // the freq col has non-missing values in normal categories%%00010                    // - add this column to the view%%00010                    var plotStream = {%%00010                        'key': col,%%00010                        'values': values%%00010                    };%%00010                    plotData.push(plotStream);%%00010%%00010                    if (customColors) {%%00010                        var color = customColors[col];%%00010                        if (!color) {%%00010                            color = '#7C7C7C';%%00010                        }%%00010                        colorScale.push(color);%%00010                    }%%00010                    numFreqColsNoMissVal++;%%00010                } else {%%00010                    // The freq col has only missing values in normal categories%%00010                    // -%%00010                    // we save whether it has a non-missing value in the Missing%%00010                    // values category.%%00010                    // Whether this column is going to be displayed in the view%%00010                    // depends on the &quot;includeMissValCat&quot; option.%%00010                    // So we don't add the column to the plot at this moment -%%00010                    // wait for processMissingValues()%%00010                    // Note: a non-missing value (if there is) is stored in%%00010                    // missValCatValues - hence, enough to store only a boolean%%00010                    // flag%%00010                    freqColValueOnMissValCat.push({%%00010                        'col': col,%%00010                        'hasValueOnMissValCat': hasValueOnMissValCat%%00010                    });%%00010                    if (hasValueOnMissValCat) {%%00010                        // If there is a non-missing value, then the presence of%%00010                        // the column depends on the &quot;includeMissValCat&quot; option,%%00010                        // which can be switched in the view on the fly.%%00010                        // We do not want this switch to influence on the color%%00010                        // scale, so we count it%%00010                        numFreqColsNoMissVal++;%%00010                    }%%00010                }%%00010            }%%00010        } else {%%00010            if (hasNull == false) {%%00010                alert('No numeric columns detected.');%%00010                return 'numeric';%%00010            } else {%%00010                alert('Numeric columns detected, but contains missing values.');%%00010                return 'missing';%%00010            }%%00010        }%%00010%%00010        if (customColors) {%%00010            colorRange = colorScale;%%00010        } else {%%00010            // Default color scale%%00010            if (numFreqColsNoMissVal &gt; 10) {%%00010                colorScale = d3.scale.category20();%%00010            } else {%%00010                colorScale = d3.scale.category10();%%00010            }%%00010            colorRange = colorScale.range();%%00010        }%%00010%%00010        processMissingValues();%%00010    };%%00010%%00010    /**%%00010%%00009 * switched - if the chart update was triggered by changing the &quot;include%%00010%%00009 * 'Missing values' category&quot; option in the view%%00010%%00009 */%%00010    processMissingValues = function (switched) {%%00010        // Make a list of freq columns to exclude%%00010        var excludeCols = []; // column names to exclude%%00010        // Go through the list of those freq cols which have only missing values%%00010        // in normal categories%%00010        // and exclude those which either 1) has a missing value in the Missing%%00010        // values category, or%%00010        // 2) has a non-missing value there but the option is set to Don't%%00010        // include missing values%%00010        for (var i = 0; i &lt; freqColValueOnMissValCat.length; i++) {%%00010            var col = freqColValueOnMissValCat[i];%%00010            if (!col.hasValueOnMissValCat || col.hasValueOnMissValCat &amp;&amp; !_value.options.includeMissValCat) {%%00010                excludeCols.push(col.col);%%00010            }%%00010        }%%00010%%00010        // Make a list of excluded bars per category or whole categories%%00010        var excludeBars = []; // bars (in string representation) to exclude%%00010        var excludeCats = []; // category names to exclude%%00010        var numLeftCols = freqCols.length - excludeCols.length; // how many%%00010        // columns left%%00010        // after%%00010        // excluded ones%%00010        var missValCatBars; // bars for Missing values category we add to the%%00010        // end, so we store them separately%%00010        var excludeWholeMissValCat = false;%%00010        excludeFreqColCatMap = {};%%00010        // We group the warnings by category, so we iterate over categories%%00010        for (var i = 0; i &lt; missValInCat.length; i++) {%%00010            var cat = categories[i];%%00010            // take only those freq cols which have missing values in the%%00010            // current category and were not whole excluded%%00010            var cols = missValInCat[i].filter(function (x) {%%00010                return excludeCols.indexOf(x) == -1;%%00010            });%%00010            if (cols.length &gt; 0) {%%00010                if (cols.length == numLeftCols) {%%00010                    // if all the left freq cols have missing values - exclude%%00010                    // the whole category%%00010                    if (cat !== null) {%%00010                        excludeCats.push(cat);%%00010                    } else {%%00010                        excludeWholeMissValCat = true; // Missing values%%00010                        // category will be%%00010                        // appended to the end%%00010                    }%%00010                } else {%%00010                    // build a string of excluded bars (cat - col1, col2 ...)%%00010                    var label = cat !== null ? cat : MISSING_VALUES_LABEL;%%00010                    var str = label + ' - ' + cols.join(', ');%%00010                    if (cat !== null) {%%00010                        excludeBars.push(str);%%00010                    } else {%%00010                        missValCatBars = str; // Missing values category will%%00010                        // be appended to the end%%00010                    }%%00010                    // for normal categories and also for the Missing values%%00010                    // category (if it's included in the view)%%00010                    // we fill the map of excluded bars (grouped by freq cols) -%%00010                    // needed for Stacked plot%%00010                    if (cat !== null || _value.options.includeMissValCat) {%%00010                        cols.forEach(function (col) {%%00010                            if (excludeFreqColCatMap[col] != undefined) {%%00010                                excludeFreqColCatMap[col].push(cat);%%00010                            } else {%%00010                                excludeFreqColCatMap[col] = [cat];%%00010                            }%%00010                        });%%00010                    }%%00010                }%%00010            }%%00010        }%%00010        // exclude smth from Missing values category, if it's included in the%%00010        // view%%00010        if (_value.options.includeMissValCat &amp;&amp; _representation.options.reportOnMissingValues) {%%00010            if (excludeWholeMissValCat) {%%00010                excludeCats.push(MISSING_VALUES_LABEL);%%00010            } else if (missValCatBars !== undefined) {%%00010                excludeBars.push(missValCatBars);%%00010            }%%00010        }%%00010%%00010        // Add or remove the non-missing values of the Missing values category%%00010        for (var i = 0; i &lt; missValCatValues.length; i++) {%%00010            var item = missValCatValues[i];%%00010            if (excludeCols.indexOf(item.col) != -1 &amp;&amp; !(!_value.options.includeMissValCat &amp;&amp; switched)) {%%00010                // Fact that the freq col is in missValCatValues means it has a%%00010                // non-missing value in Missing values category.%%00010                // If this col was excluded, that means it has only missing%%00010                // values in all other categories AND we &quot;don't include%%00010                // MissValCat&quot;.%%00010                // In case it's the first time the plot is building, we don't%%00010                // need to do anything - call continue.%%00010                // But if a user switched the option &quot;includeMissValCat&quot; from%%00010                // 'on' to 'off', we need to remove the value of MissValCat from%%00010                // the plot further below.%%00010                continue;%%00010            }%%00010            // find if the plot has already the data (key-&gt;values) for the%%00010            // current freq col == key%%00010            var data = undefined;%%00010            var dataInd;%%00010            for (var j = 0; j &lt; plotData.length; j++) { // many thanks to IE -%%00010                // we cannot use find()%%00010                // or findIndex() here%%00010                if (plotData[j].key == item.col) {%%00010                    data = plotData[j];%%00010                    dataInd = j;%%00010                    break;%%00010                }%%00010            }%%00010            if (_value.options.includeMissValCat &amp;&amp; _representation.options.reportOnMissingValues) {%%00010                // if we include Missing values category to the view, we need to%%00010                // add its values%%00010                var val = {%%00010                    'x': MISSING_VALUES_LABEL,%%00010                    'y': item.value%%00010                };%%00010                if (data !== undefined) {%%00010                    data.values.push(val);%%00010                } else {%%00010                    plotData.push({%%00010                        'key': item.col,%%00010                        'values': [val]%%00010                    });%%00010                }%%00010            } else if (switched) {%%00010                // if we don't include Missing values category to the view AND%%00010                // this option was switched in the view, we need to remove its%%00010                // value%%00010                if (data !== undefined) {%%00010                    data.values.pop();%%00010                    if (data.values.length == 0) {%%00010                        plotData.splice(dataInd, 1);%%00010                    }%%00010                }%%00010            }%%00010        }%%00010%%00010        // Set warning messages%%00010        if (!showWarnings) {%%00010            return;%%00010        }%%00010        if (plotData.length == 0) {%%00010            // No data available warnings%%00010            var str;%%00010            if (missValCatValues.length != 0 &amp;&amp; _representation.options.reportOnMissingValues) {%%00010                str = 'No chart was generated since all frequency columns have only missing values.\nThere are values where the category name is missing.\nTo see them switch on the option &quot;Include \'Missing values\' category&quot; in the view settings.';%%00010            } else {%%00010                str = 'No chart was generated since all frequency columns have only missing values or empty.\nRe-run the workflow with different data.';%%00010            }%%00010            knimeService.setWarningMessage(str, NO_DATA_AVAILABLE);%%00010        } else {%%00010            knimeService.clearWarningMessage(NO_DATA_AVAILABLE);%%00010            // All other warnings%%00010            if (excludeCols.length &gt; 0 &amp;&amp; _representation.options.reportOnMissingValues) {%%00010                knimeService.setWarningMessage(%%00010                    'Following frequency columns are not present or contain only missing values and were excluded from the view:\n    '%%00010%%00009%%00009%%00009%%00009%%00009+ excludeCols.join(', '), FREQ_COLUMN_MISSING_VALUES_ONLY);%%00010            } else {%%00010                knimeService.clearWarningMessage(FREQ_COLUMN_MISSING_VALUES_ONLY);%%00010            }%%00010%%00010            if (excludeCats.length &gt; 0 &amp;&amp; _representation.options.reportOnMissingValues) {%%00010                knimeService.setWarningMessage(%%00010                    'Following categories contain only missing values and were excluded from the view:\n    '%%00010%%00009%%00009%%00009%%00009%%00009+ excludeCats.join(', '), CATEGORY_MISSING_VALUES_ONLY);%%00010            } else {%%00010                knimeService.clearWarningMessage(CATEGORY_MISSING_VALUES_ONLY);%%00010            }%%00010%%00010            if (excludeBars.length &gt; 0 &amp;&amp; _representation.options.reportOnMissingValues) {%%00010                knimeService.setWarningMessage(%%00010                    'Following bars contain only missing values in frequency column and were excluded from the view:\n    '%%00010%%00009%%00009%%00009%%00009%%00009+ excludeBars.join('\n    '), MISSING_VALUES_ONLY);%%00010            } else {%%00010                knimeService.clearWarningMessage(MISSING_VALUES_ONLY);%%00010            }%%00010        }%%00010    };%%00010%%00010    /**%%00010%%00009 * This is a workaround for the stacked plot problem coming from the nvd3%%00010%%00009 * library implementation. They do not really support missing values in the%%00010%%00009 * Stacked option: (https://github.com/novus/nvd3/issues/1941 - &quot;The%%00010%%00009 * solution is to adjust your data before handing it to nvd3.&quot; - nice%%00010%%00009 * answer) The implementation uses a simple d3.layout.stack which requires%%00010%%00009 * all data have the same length%%00010%%00009 * (https://github.com/d3/d3-3.x-api-reference/blob/master/Stack-Layout.md#_stack)%%00010%%00009 * Missing values may lead to different lengths. A workaround here is to add%%00010%%00009 * dummy null values in place of excluded bars before drawing to Stacked%%00010%%00009 * plot. And remove them before switching to Grouped plot.%%00010%%00009 */%%00010    fixStackedData = function (addDummy) {%%00010        plotData.forEach(function (dataValues) {%%00010            var excludeCats = excludeFreqColCatMap[dataValues.key];%%00010            if (excludeCats == undefined) {%%00010                // if this freq col does not have excluded bars at all - nothing%%00010                // to do%%00010                return;%%00010            }%%00010            if (addDummy) {%%00010                // Another implementation thing is that the categories in every%%00010                // freq col must follow the same order.%%00010                // So we cannot simply append dummy nulls to the end.%%00010                // Instead we need to replace the whole &quot;values&quot; array.%%00010                // We go over the categories and add either a real value or a%%00010                // dummy null depending on what's present.%%00010                var i = 0, j = 0;%%00010                var values = dataValues.values;%%00010                var newValues = [];%%00010                categories.forEach(function (cat) {%%00010                    if (cat == null) {%%00010                        return;%%00010                    }%%00010                    if (i &lt; values.length &amp;&amp; values[i].x == cat) {%%00010                        newValues.push(values[i]);%%00010                        i++;%%00010                    } else if (j &lt; excludeCats.length &amp;&amp; excludeCats[j] == cat) {%%00010                        newValues.push({%%00010                            'x': cat,%%00010                            'y': null%%00010                        });%%00010                        j++;%%00010                    }%%00010                });%%00010                if (i &lt; values.length &amp;&amp; values[i].x == MISSING_VALUES_LABEL) {%%00010                    newValues.push(values[i]);%%00010                } else if (j &lt; excludeCats.length &amp;&amp; excludeCats[j] == null) {%%00010                    newValues.push({%%00010                        'x': MISSING_VALUES_LABEL,%%00010                        'y': null%%00010                    });%%00010                }%%00010                dataValues.values = newValues;%%00010            } else {%%00010                // remove dummy null values (basically any null values as there%%00010                // can be no other nulls)%%00010                dataValues.values = dataValues.values.filter(function (value) {%%00010                    return value.y !== null;%%00010                });%%00010            }%%00010        });%%00010    };%%00010%%00010    function updateTitles(updateChart) {%%00010        if (chart) {%%00010            var curTitle = d3.select('#title');%%00010            var curSubtitle = d3.select('#subtitle');%%00010            var chartNeedsUpdating = curTitle.empty() != !(_value.options.title)%%00010%%00009%%00009%%00009%%00009|| curSubtitle.empty() != !(_value.options.subtitle);%%00010            if (!_value.options.title) {%%00010                curTitle.remove();%%00010            }%%00010            if (_value.options.title) {%%00010                if (curTitle.empty()) {%%00010                    svg.append('text')%%00010                        .attr('x', 20)%%00010                        .attr('y', 30)%%00010                        .attr('id', 'title')%%00010                        .attr('class', 'knime-title')%%00010                        .text(_value.options.title);%%00010                } else {%%00010                    curTitle.text(_value.options.title);%%00010                }%%00010            }%%00010            if (!_value.options.subtitle) {%%00010                curSubtitle.remove();%%00010            }%%00010            if (_value.options.subtitle) {%%00010                if (curSubtitle.empty()) {%%00010                    svg.append('text')%%00010                        .attr('x', 20)%%00010                        .attr('y', _value.options.title ? 46 : 20)%%00010                        .attr('id', 'subtitle')%%00010                        .attr('class', 'knime-subtitle')%%00010                        .text(_value.options.subtitle);%%00010                } else {%%00010                    curSubtitle.text(_value.options.subtitle).attr('y', _value.options.title ? 46 : 20);%%00010                }%%00010            }%%00010%%00010            var topMargin = 10;%%00010            topMargin += _value.options.title ? 10 : 0;%%00010            topMargin += _value.options.subtitle ? 8 : 0;%%00010            if (_representation.options['legend']) {%%00010                chart.legend.margin({%%00010                    top : topMargin,%%00010                    bottom : topMargin%%00010                });%%00010            } else {%%00010                chart.margin({%%00010                    top : topMargin * 2%%00010                });%%00010            }%%00010%%00010            var isTitle = _value.options.title || _value.options.subtitle;%%00010            knimeService.floatingHeader(isTitle);%%00010%%00010            if (updateChart &amp;&amp; chartNeedsUpdating) {%%00010                if (_representation.options.svg.fullscreen &amp;&amp; _representation.runningInView) {%%00010                    var height = (isTitle) ? '100%' : 'calc(100% - ' + knimeService.headerHeight() + 'px)';%%00010                    layoutContainer.style('height', height)%%00010                    // two rows below force to invalidate the container which%%00010                    // solves a weird problem with vertical scroll bar in IE%%00010                        .style('display', 'none')%%00010                        .style('display', 'block');%%00010                    d3.select('#svgContainer').style('height', height);%%00010                }%%00010                chart.update();%%00010            }%%00010        }%%00010    }%%00010%%00010    /**%%00010%%00009 * Updates the axis labels after they have been wrapped. And add a title to%%00010%%00009 * show the full name. Additionally adjust the length of the maximum and%%00010%%00009 * minimum value on the y-axis.%%00010%%00009 */%%00010    function updateLabels() {%%00010        var optShowMaximum = _value.options.showMaximum;%%00010        if (typeof optShowMaximum == 'undefined') {%%00010            optShowMaximum = _representation.options.showMaximum;%%00010        }%%00010        var optOrientation = _value.options['orientation'];%%00010        var texts = svg.select('.knime-x').selectAll('text');%%00010        texts.each(function (d, i) {%%00010            if (typeof wrapedPlotData[0].values[i] !== 'undefined') {%%00010                var self = d3.select(this);%%00010                self.text(wrapedPlotData[0].values[i].x);%%00010                self.append('title').classed('knime-tooltip', true);%%00010            }%%00010        });%%00010        var stacked = _value.options['chartType'];%%00010        var extremValues = [];%%00010    %%00009if(stacked == &quot;Grouped&quot;) {%%00010    %%00009%%00009extremValues = getRoundedMaxValue(false);%%00009%%00010    %%00009} else {%%00010    %%00009%%00009extremValues = getRoundedMaxValue(true);%%00010    %%00009}%%00010    %%00009var minValue = extremValues[0];%%00010    %%00009var maxValue = extremValues[1];%%00010    %%00009%%00010        var tickAmount = chart.yAxis.ticks();%%00010        if (tickAmount &lt; 2) {%%00010            tickAmount = 2;%%00010        }%%00010%%00010        var scale = d3.scale.linear().domain([minValue, maxValue]);%%00010%%00010        var textsYMin, textsYMax;%%00010        if (optShowMaximum) {%%00010            if (optOrientation) {%%00010                textsYMin = svg.select('.nv-axisMin-x').selectAll('text');%%00010                textsYMax = svg.select('.nv-axisMax-x').selectAll('text');%%00010            } else {%%00010                textsYMin = svg.select('.nv-axisMin-y').selectAll('text');%%00010                textsYMax = svg.select('.nv-axisMax-y').selectAll('text');%%00010            }%%00010            textsYMin.text(minValue);%%00010            textsYMax.text(maxValue);%%00010        }%%00010%%00010        var labelTooltip = texts.selectAll('.knime-tooltip');%%00010        var counter = 0;%%00010        labelTooltip.each(function (d, i) {%%00010            var self = d3.select(this);%%00010            if (typeof plotData[0].values[counter] !== 'undefined') {%%00010                self.text(plotData[0].values[counter].x);%%00010            }%%00010            counter++;%%00010        });%%00010%%00010        // Create titles for the Axis-Tooltips%%00010        svg.select('.knime-y text.knime-axis-label').append('title').classed('knime-tooltip', true).text(%%00010            _value.options['freqLabel']);%%00010        svg.select('.knime-x text.knime-axis-label').append('title').classed('knime-tooltip', true).text(%%00010            _value.options['catLabel']);%%00010    }%%00010    %%00010    function getRoundedMaxValue(isStacked) {%%00010     %%00009var maxValue = 0;%%00010     %%00009var minValue = 0;%%00010     %%00009var considerNegativeList = false;%%00010     %%00009if(isStacked) {%%00010        %%00009var sumListPositive = [];%%00010        %%00009var sumListNegative = [];%%00010%%00009        for (var i = 0; i &lt; plotData.length; i++) {%%00010%%00009        %%00009for (var j = 0; j &lt; plotData[i].values.length; j++) { %%00010%%00009%%00009        %%00009if(sumListPositive.length &lt; plotData[i].values.length) {%%00010%%00009%%00009        %%00009%%00009sumListPositive.push(0);%%00010%%00009%%00009        %%00009%%00009sumListNegative.push(0);%%00010%%00009%%00009        %%00009} %%00010%%00009        %%00009%%00009if(plotData[i].disabled !== true) {%%00010%%00009        %%00009%%00009%%00009if(plotData[i].values[j].y&gt;0) {%%00010%%00009        %%00009%%00009%%00009%%00009sumListPositive[j] += plotData[i].values[j].y;%%00010%%00009        %%00009%%00009%%00009} else {%%00010%%00009        %%00009%%00009%%00009%%00009sumListNegative[j] += plotData[i].values[j].y;%%00010%%00009        %%00009%%00009%%00009%%00009considerNegativeList = true;%%00010%%00009        %%00009%%00009%%00009}%%00010%%00009        %%00009%%00009} %%00010%%00009        %%00009}%%00010%%00009        }%%00010%%00009        maxValue = d3.max(sumListPositive);%%00010%%00009        if(considerNegativeList) {%%00010%%00009        %%00009minValue = d3.min(sumListNegative);%%00010%%00009        }%%00010     %%00009} else {%%00010%%00009        for (var i = 0; i &lt; plotData.length; i++) {%%00010%%00009        %%00009if(plotData[i].disabled !== true) {%%00010%%00009%%00009            var tempMaxValue = Math.max(d3.max(plotData[i].values, function (d) {%%00010%%00009%%00009                return parseFloat(d.y);%%00010%%00009%%00009            }), 0);%%00010%%00009%%00009            if(tempMaxValue &gt; maxValue) {maxValue = tempMaxValue;}%%00010%%00009%%00009            var tempMinValue = Math.min(d3.min(plotData[i].values, function (d) {%%00010%%00009%%00009                return parseFloat(d.y);%%00010%%00009%%00009            }), 0);%%00010%%00009%%00009            if(tempMinValue &lt; minValue) {minValue = tempMinValue;}%%00010%%00009        %%00009}%%00010%%00009        }%%00010     %%00009}%%00010     %%00009%%00010        var tickAmount = chart.yAxis.ticks();%%00010        if (tickAmount &lt; 2) {%%00010        %%00009tickAmount = 2;%%00010        }%%00010%%00010        var scale = d3.scale.linear().domain([minValue, maxValue]);%%00010    %%00009var ticks = scale.ticks(tickAmount);%%00010    %%00009var precision = 1;%%00010    %%00009for (var i = 0; i &lt; ticks.length; i++) {%%00010            if (ticks[i] !== 0) {%%00010                var curTick = ticks[i];%%00010                if (curTick.toString().indexOf('.') &gt;= 0) {%%00010                    // +1 because the precision of the maximum should be one%%00010                    // decimal more then the normal ticks%%00010                    precision = Math.max((curTick.toString().split('.')[1].length) + 1, precision);%%00010                } else if (curTick.toString().indexOf('e') &gt;= 0) {%%00010                    precision = Math.max(Math.abs(parseFloat(curTick.toString().split('e')[1])), precision);%%00010                }%%00010            }%%00010        }%%00010    %%00009%%00010    %%00009var roundedMaxValue = Math.ceil(parseFloat(maxValue) * Math.pow(10, precision)) / Math.pow(10, precision);%%00010    %%00009var roundedMinValue = Math.floor(parseFloat(minValue) * Math.pow(10, precision)) / Math.pow(10, precision);%%00010    %%00009return [roundedMinValue,roundedMaxValue];%%00010    }%%00010%%00010    /**%%00010%%00009 * Find the max size of one element on the y-axis to see how much space is%%00010%%00009 * needed. To find out the max size, a temp-text object is created and%%00010%%00009 * measured. Afterwards that temp-text is deleted (is not visible in the%%00010%%00009 * view).%%00010%%00009 */%%00010    function checkMaxSizeYAxis(number, optShowMaximum) {%%00010    %%00009var maxValue = 0, minValue = 0;%%00010    %%00009var extremValues = [];%%00010    %%00009var stacked = _value.options['chartType'];%%00010    %%00009if(stacked == &quot;Grouped&quot;) {%%00010    %%00009%%00009extremValues = getRoundedMaxValue(false);%%00009%%00010    %%00009} else {%%00010    %%00009%%00009extremValues = getRoundedMaxValue(true);%%00010    %%00009}%%00010    %%00009minValue = extremValues[0];%%00010    %%00009maxValue = extremValues[1];%%00010       %%00010        var svgHeight = parseInt(d3.select('svg').style('height'));%%00010        var svgWidth = parseInt(d3.select('svg').style('width'));%%00010%%00010        // Calculate values of the y-axis to get an impression about the%%00010        // precision.%%00010        var scale = d3.scale.linear().domain([minValue, maxValue]).range(%%00010            [0, _representation.options['svg']['height']]);%%00010        var ticks = scale.ticks(4);%%00010        if (optShowMaximum) {%%00010            if (maxValue.toString().indexOf('.') &gt; 0 ) {%%00010            %%00009if(ticks[ticks.length-1].toString().indexOf('.') &gt; 0) {%%00010            %%00009%%00009var decimalString = ticks[ticks.length - 1].toString().split('.')[1];%%00010            %%00009%%00009ticks.push(parseFloat((maxValue.toFixed(decimalString.length)+1)));            %%00009%%00009%%00010            %%00009} else {%%00010            %%00009%%00009ticks.push(parseFloat(maxValue.toFixed(0)));%%00010            %%00009}%%00010            } else {%%00010                ticks.push(maxValue);%%00010            }%%00010            if (minValue &lt; 0 &amp;&amp; minValue.toString().indexOf('e') &lt; 0) {%%00010            %%00009if(ticks[0].toString().split('.')[1]) {%%00010            %%00009%%00009ticks.push((minValue.toFixed(ticks[0].toString().split('.')[1].length - 1)));%%00010            %%00009} else {%%00010            %%00009%%00009ticks.push((minValue.toFixed(1)));%%00010            %%00009}%%00010            } else if (minValue &lt; 0) {%%00010                ticks.push(minValue);%%00010            }%%00010        }%%00010        var configObject = {%%00010            container: document.querySelector('svg'),%%00010            tempContainerClasses: 'knime-axis',%%00010            maxWidth: svgWidth,%%00010            maxHeight: svgHeight * 0.1,%%00010        };%%00010%%00010        var results = knimeService.measureAndTruncate(ticks, configObject);%%00010%%00010        // Return the format to show the result and the space needed to the left%%00010        // border.%%00010        return results;%%00010    }%%00010%%00010    /**%%00010%%00009 * Find the max size of the biggest element on the x-Axis. Move the Graph so%%00010%%00009 * that this object is completely visible.%%00010%%00009 */%%00010    function checkMaxSizeXAxis(number, staggerLabels) {%%00010        var optOrientation = _value.options['orientation'];%%00010        var svgHeight = parseInt(d3.select('svg').style('height'));%%00010        var svgWidth = parseInt(d3.select('svg').style('width'));%%00010        var amountOfBars = number[0].values.length;%%00010        var amountOfDimensions = number.length;%%00010        %%00010        var spaceBetweenBars = _representation.isHistogram ? 0 : 40; %%00010        var maxWidth;%%00010        if(optOrientation) {%%00010        %%00009maxWidth = 0.5 * svgWidth;%%00010        } else {%%00010        %%00009var barWidth;%%00010        %%00009if((d3.select(&quot;.nv-groups&quot;).node()) !== null) {%%00010        %%00009%%00009barWidth = d3.select(&quot;.nv-groups&quot;).select(&quot;rect&quot;)[0][0].width.baseVal.value * amountOfDimensions;%%00010        %%00009} else {%%00010        %%00009%%00009barWidth = (svgWidth / amountOfBars) - spaceBetweenBars%%00010        %%00009}%%00010        %%00009if(staggerLabels) {%%00010        %%00009%%00009maxWidth = barWidth * 2;%%00010        %%00009} else {%%00010        %%00009%%00009maxWidth = barWidth;%%00010        %%00009}%%00010        }%%00010%%00010        var configObject = {%%00010            container: document.querySelector('svg'),%%00010            tempContainerClasses: 'knime-axis',%%00010            maxWidth: _representation.isHistogram ? undefined : maxWidth,%%00010            /*maxHeight: svgHeight / amountOfBars,*/%%00010            minimalChars: 1,%%00010        };%%00010        var xValues = [];%%00010        for (var value in number[0].values) {%%00010            xValues.push(number[0].values[value].x);%%00010        }%%00010%%00010        var results = knimeService.measureAndTruncate(xValues, configObject);%%00010        %%00010        var xExtremValues = [];%%00010        xExtremValues.push(number[0].values[0].x);%%00010        xExtremValues.push(number[0].values[number[0].values.length-1].x);%%00010        %%00010        if(staggerLabels) {%%00010        %%00009if(!optOrientation) {%%00010    %%00009%%00009%%00009configObject.maxWidth = (svgWidth / amountOfBars) - spaceBetweenBars;%%00010        %%00009} %%00010        }%%00010        var extremResults = knimeService.measureAndTruncate(xExtremValues, configObject);%%00010%%00010        // Update the cloned data array to contain the wrapped labels%%00010        for (var group in number) {%%00010            for (var value in number[group].values) {%%00010            %%00009if(value == 0) {%%00010            %%00009%%00009wrapedPlotData[group].values[value].x = extremResults.values[0].truncated;%%00010            %%00009} else if(value == number[group].values.length-1) {%%00010            %%00009%%00009wrapedPlotData[group].values[value].x = extremResults.values[1].truncated;%%00010            %%00009} else {%%00010            %%00009    var val = results.values[parseInt(value)];%%00010            %%00009    wrapedPlotData[group].values[value].x = typeof val === 'undefined' ? null : val.truncated;%%00010            %%00009}%%00010            }%%00010        }%%00010        return results;%%00010    }%%00010%%00010    function updateAxisLabels(updateChart) {%%00010%%00010        if (chart) {%%00010            var optOrientation = _value.options['orientation'];%%00010            var optStaggerLabels = _value.options['staggerLabels'];%%00010            var stacked = _value.options['chartType'];%%00010            var optShowMaximum = _value.options.showMaximum;%%00010            var curCatAxisLabel, curFreqAxisLabel;%%00010            var curCatAxisLabelElement = d3.select('.nv-x.nv-axis .nv-axis-label');%%00010            var curFreqAxisLabelElement = d3.select('.nv-y.nv-axis .nv-axis-label');%%00010            var freqLabel = _value.options['freqLabel'];%%00010            var catLabel = _value.options['catLabel'];%%00010            var svgHeight = parseInt(d3.select('svg').style('height'));%%00010            var svgWidth = parseInt(d3.select('svg').style('width'));%%00010%%00010            if (typeof optShowMaximum == 'undefined') {%%00010                optShowMaximum = _representation.options.showMaximum;%%00010            }%%00010%%00010            wrapedPlotData = JSON.parse(JSON.stringify(plotData));%%00010%%00010            if (!curCatAxisLabelElement.empty()) {%%00010                curCatAxisLabel = curCatAxisLabelElement.text();%%00010            }%%00010%%00010            if (!curFreqAxisLabelElement.empty()) {%%00010                curFreqAxisLabel = curCatAxisLabelElement.text();%%00010            }%%00010%%00010            var chartNeedsUpdating = curCatAxisLabel != _value.options.catLabel%%00010%%00009%%00009%%00009%%00009|| curFreqAxisLabel != _value.options.freqLabel;%%00010            if (!chartNeedsUpdating)%%00010                return;%%00010%%00010            var configObject = {%%00010                container: document.querySelector('svg'),%%00010                tempContainerClasses: 'knime-axis',%%00010                maxWidth: svgWidth * 0.5,%%00010                maxHeight: svgHeight * 0.5,%%00010                minimalChars: 1,%%00010            };%%00010            optOrientation ? configObject.tempContainerAttributes = { transform: 'rotate(-90)' }%%00010                : configObject.tempContainerAttributes = '';%%00010            var catLabelSize = knimeService.measureAndTruncate(catLabel ? [catLabel] : [''], configObject);%%00010            optOrientation ? configObject.tempContainerAttributes.transform = ''%%00010                : configObject.tempContainerAttributes = { transform: 'rotate(-90)' };%%00010            var freqLabelSize = knimeService.measureAndTruncate(freqLabel ? [freqLabel] : [''], configObject);%%00010%%00010            var maxSizeYAxis = checkMaxSizeYAxis(wrapedPlotData, optShowMaximum);%%00010            var maxSizeXAxis = checkMaxSizeXAxis(wrapedPlotData, optStaggerLabels);%%00010            var svgSize = optOrientation ? parseInt(d3.select('svg').style('width')) : parseInt(d3.select('svg').style(%%00010                'height'));%%00010%%00010            freqLabel = freqLabelSize.values[0].truncated;%%00010            catLabel = catLabelSize.values[0].truncated;%%00010            %%00010            // space between two labels%%00010            var distanceBetweenLabels = 150;%%00010            if (optOrientation) {%%00010            %%00009var tickAmount = parseInt((svgSize - maxSizeXAxis.max.maxWidth) / (maxSizeYAxis.max.maxWidth + distanceBetweenLabels));%%00010                if (optShowMaximum) {%%00010                %%00009// extend the border of the svg to be able to see the complete maximum label %%00010                %%00009// factor 0.6 is chosen to give the label a little space to the border%%00010                %%00009var rightMargin = 0.6 * maxSizeYAxis.max.maxWidth;%%00010                }%%00010            } else {%%00010            %%00009var tickAmount = parseInt((svgSize - maxSizeYAxis.max.maxHeight) / (maxSizeYAxis.max.maxHeight + distanceBetweenLabels));%%00010            }%%00010            %%00010            // nvd3 sets the cat label 55 pixel away from the axis. As with changing font size this%%00010            // is not enough, it is easier to calculate it ourselves%%00010            var spacingCatLabel = 55;%%00010            %%00010            // nvd3 sets the freq label 20 pixel away from the axis. As with changing font size this%%00010            // is not enough, it is easier to calculate it ourselves%%00010            var spacingFreqLabel = 20;%%00010            %%00010            // add some empty space, so that two labels are not to close together%%00010            var additionalEmptySpace = 15;%%00010%%00010            var paddingAmount = 15;%%00010            chart.xAxis%%00010                .axisLabel(catLabel)%%00010                .axisLabelDistance(optOrientation ? maxSizeXAxis.max.maxWidth - spacingCatLabel + additionalEmptySpace + paddingAmount%%00010                %%00009%%00009: optStaggerLabels ? maxSizeXAxis.max.maxHeight*2 -spacingCatLabel + additionalEmptySpace *2 + paddingAmount%%00010                %%00009%%00009: -spacingFreqLabel + maxSizeXAxis.max.maxHeight * 1.5)%%00010                .tickPadding(paddingAmount)%%00010                .showMaxMin(false);%%00010%%00010            chart.yAxis.axisLabel(freqLabel)%%00010                .axisLabelDistance(optOrientation ? -spacingFreqLabel + maxSizeYAxis.max.maxHeight%%00010                %%00009%%00009: (maxSizeYAxis.max.maxWidth - spacingCatLabel + additionalEmptySpace))%%00010                .showMaxMin(optShowMaximum)%%00010                .ticks(tickAmount)%%00010                .tickFormat(d3.format('~.g'));%%00010            %%00010            var extremValues = [];%%00010        %%00009if(stacked == &quot;Grouped&quot;) {%%00010        %%00009%%00009extremValues = getRoundedMaxValue(false);%%00010        %%00009} else {%%00010        %%00009%%00009extremValues = getRoundedMaxValue(true);%%00010        %%00009}%%00010        %%00009chart.yDomain([extremValues[0],extremValues[1]]);%%00010            %%00010        %%00009var bottomMargin = optOrientation ? maxSizeYAxis.max.maxHeight + freqLabelSize.max.maxHeight + additionalEmptySpace%%00010        %%00009%%00009%%00009: maxSizeXAxis.max.maxHeight + catLabelSize.max.maxHeight + additionalEmptySpace;%%00010        %%00009var leftMargin = optOrientation ? maxSizeXAxis.max.maxWidth + catLabelSize.max.maxWidth + additionalEmptySpace + paddingAmount%%00010        %%00009%%00009%%00009: maxSizeYAxis.max.maxWidth + freqLabelSize.max.maxWidth + additionalEmptySpace;%%00010        %%00009%%00010            if (!_value.options.catLabel) {%%00010                bottomMargin = optOrientation ? bottomMargin%%00010                %%00009%%00009: maxSizeXAxis.max.maxHeight + additionalEmptySpace;%%00010                leftMargin = optOrientation ? leftMargin : maxSizeYAxis.max.maxWidth%%00010                %%00009%%00009+ freqLabelSize.max.maxWidth + additionalEmptySpace;%%00010            }%%00010            if (!_value.options.freqLabel) {%%00010            %%00009bottomMargin = optOrientation ? maxSizeXAxis.max.maxHeight + additionalEmptySpace : bottomMargin;%%00010                leftMargin = optOrientation ? leftMargin + paddingAmount%%00010                %%00009%%00009: maxSizeYAxis.max.maxWidth + additionalEmptySpace;%%00010            }%%00010            if (!optOrientation) {%%00010                chart.staggerLabels(optStaggerLabels);%%00010                if (optStaggerLabels) {%%00010                %%00009bottomMargin += _value.options.catLabel ? 0.25 *maxSizeXAxis.max.maxHeight + paddingAmount%%00010                        : 0.5 * maxSizeXAxis.max.maxHeight + paddingAmount;%%00010                }%%00010            }%%00010            chart.margin({%%00010                left: leftMargin,%%00010                bottom: bottomMargin,%%00010                right: rightMargin%%00010            });%%00010%%00010            if (updateChart) {%%00010                chart.update();%%00010            }%%00010        }%%00010    }%%00010%%00010    function updateChartType() {%%00010        if (this.value != _value.options.chartType) {%%00010            _value.options.chartType = this.value;%%00010            var stacked = this.value == 'Stacked';%%00010            fixStackedData(stacked);%%00010            chart.stacked(stacked);%%00010            drawChart(true);%%00010        }%%00010    }%%00010%%00010    drawControls = function () {%%00010        if (!knimeService) {%%00010            return;%%00010        }%%00010%%00010        if (_representation.options.displayFullscreenButton) {%%00010            knimeService.allowFullscreen();%%00010        }%%00010%%00010        if (!_representation.options.enableViewControls)%%00010            return;%%00010%%00010        var titleEdit = _representation.options.enableTitleEdit;%%00010        var subtitleEdit = _representation.options.enableSubtitleEdit;%%00010        var axisEdit = _representation.options.enableAxisEdit;%%00010        var chartTypeEdit = _representation.options.enableStackedEdit;%%00010        var orientationEdit = _representation.options.enableHorizontalToggle;%%00010        var staggerLabels = _representation.options.enableStaggerToggle;%%00010        var switchMissValCat = _representation.options.enableSwitchMissValCat;%%00010        var showMaximum = _representation.options.enableMaximumValue;%%00010        var enableSelection = _representation.options.enableSelection;%%00010        var displayClearButton = _representation.options.displayClearSelectionButton;%%00010%%00010        if (titleEdit || subtitleEdit) {%%00010            if (titleEdit) {%%00010                var chartTitleText = knimeService.createMenuTextField('chartTitleText', _value.options.title,%%00010                    function () {%%00010                        if (_value.options.title != this.value) {%%00010                            _value.options.title = this.value;%%00010                            updateTitles(true);%%00010                        }%%00010                    }, true);%%00010                knimeService.addMenuItem('Chart Title:', 'header', chartTitleText);%%00010            }%%00010            if (subtitleEdit) {%%00010                var chartSubtitleText = knimeService.createMenuTextField('chartSubtitleText', _value.options.subtitle,%%00010                    function () {%%00010                        if (_value.options.subtitle != this.value) {%%00010                            _value.options.subtitle = this.value;%%00010                            updateTitles(true);%%00010                        }%%00010                    }, true);%%00010                var mi = knimeService.addMenuItem('Chart Subtitle:', 'header', chartSubtitleText, null,%%00010                    knimeService.SMALL_ICON);%%00010            }%%00010            if (axisEdit || orientationEdit || staggerLabels) {%%00010                knimeService.addMenuDivider();%%00010            }%%00010        }%%00010%%00010        if (axisEdit) {%%00010            var catAxisText = knimeService.createMenuTextField('catAxisText', _value.options.catLabel, function () {%%00010                _value.options.catLabel = this.value;%%00010                updateAxisLabels(true);%%00010            }, true);%%00010            knimeService.addMenuItem('Category axis label:', 'ellipsis-h', catAxisText);%%00010%%00010            var freqAxisText = knimeService.createMenuTextField('freqAxisText', _value.options.freqLabel, function () {%%00010                _value.options.freqLabel = this.value;%%00010                updateAxisLabels(true);%%00010            }, true);%%00010            knimeService.addMenuItem('Frequency axis label:', 'ellipsis-v', freqAxisText);%%00010%%00010            if (switchMissValCat || orientationEdit || staggerLabels || chartTypeEdit) {%%00010                knimeService.addMenuDivider();%%00010            }%%00010        }%%00010%%00010        if (switchMissValCat &amp;&amp; isMissValCat &amp;&amp; _representation.options.reportOnMissingValues) {%%00010            var switchMissValCatCbx = knimeService.createMenuCheckbox('switchMissValCatCbx',%%00010                _value.options.includeMissValCat, function () {%%00010                    if (_value.options.includeMissValCat != this.checked) {%%00010                        _value.options.includeMissValCat = this.checked;%%00010                        var stacked = _value.options.chartType == 'Stacked';%%00010                        if (stacked) {%%00010                            fixStackedData(false);%%00010                        }%%00010                        processMissingValues(true);%%00010                        if (stacked) {%%00010                            fixStackedData(true);%%00010                        }%%00010                        chart.update();%%00010                    }%%00010                });%%00010            knimeService.addMenuItem('Include \'Missing values\' category: ', 'question', switchMissValCatCbx);%%00010%%00010            if (orientationEdit || staggerLabels || chartTypeEdit) {%%00010                knimeService.addMenuDivider();%%00010            }%%00010        }%%00010%%00010        if (chartTypeEdit) {%%00010            var groupedRadio = knimeService.createMenuRadioButton('groupedRadio', 'chartType', 'Grouped',%%00010                updateChartType);%%00010            groupedRadio.checked = (_value.options.chartType == groupedRadio.value);%%00010            knimeService.addMenuItem('Grouped:', 'align-left fa-rotate-270', groupedRadio);%%00010%%00010            var stackedRadio = knimeService.createMenuRadioButton('stackedRadio', 'chartType', 'Stacked',%%00010                updateChartType);%%00010            stackedRadio.checked = (_value.options.chartType == stackedRadio.value);%%00010            knimeService.addMenuItem('Stacked:', 'tasks fa-rotate-270', stackedRadio);%%00010%%00010            if (orientationEdit || staggerLabels) {%%00010                knimeService.addMenuDivider();%%00010            }%%00010        }%%00010%%00010        if (orientationEdit) {%%00010            var orientationCbx = knimeService.createMenuCheckbox('orientationCbx', _value.options.orientation,%%00010                function () {%%00010                    if (_value.options.orientation != this.checked) {%%00010                        _value.options.orientation = this.checked;%%00010                        d3.select('#staggerCbx').property('disabled', this.checked);%%00010                        drawChart(true);%%00010                    }%%00010                });%%00010            knimeService.addMenuItem('Plot horizontal bar chart:', 'align-left', orientationCbx);%%00010        }%%00010%%00010        if (staggerLabels) {%%00010            var staggerCbx = knimeService.createMenuCheckbox('staggerCbx', _value.options.staggerLabels, function () {%%00010                if (_value.options.staggerLabels != this.checked) {%%00010                    _value.options.staggerLabels = this.checked;%%00010                    drawChart(true);%%00010                }%%00010            });%%00010            staggerCbx.disabled = _value.options.orientation;%%00010            knimeService.addMenuItem('Stagger labels:', 'map-o', staggerCbx);%%00010        }%%00010%%00010        if (showMaximum) {%%00010            var displayMaximumCbx = knimeService.createMenuCheckbox('displayMaximumCbx', _value.options.showMaximum,%%00010                function () {%%00010                    if (_value.options.showMaximum != this.checked) {%%00010                        _value.options.showMaximum = this.checked;%%00010                        drawChart(true);%%00010                    }%%00010                });%%00010            knimeService.addMenuItem('Display maximum value:', 'arrows-v', displayMaximumCbx);%%00010        }%%00010        %%00010        if (enableSelection) {%%00010        %%00009knimeService.addMenuDivider();%%00010        %%00009var subscribeToSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-double-right', 'faded right sm', 'left bold');%%00010        %%00009var subscribeToSelectionMenu = knimeService.createMenuCheckbox('subscribeToSelection', %%00010        %%00009%%00009%%00009_value.options.subscribeToSelection, function () {%%00010        %%00009%%00009if (_value.options.subscribeToSelection != this.checked) {%%00010        %%00009%%00009%%00009_value.options.subscribeToSelection = this.checked;%%00010        %%00009%%00009%%00009subscribeToSelection(_value.options.subscribeToSelection);%%00010        %%00009%%00009}%%00010        %%00009});%%00010        %%00009knimeService.addMenuItem('Subscribe to selection:', subscribeToSelectionIcon, subscribeToSelectionMenu);%%00010        %%00009%%00010        %%00009var publishSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-right', 'faded left sm', 'right bold');%%00010            var publishSelectionMenu = knimeService.createMenuCheckbox('publishSelection', _value.options.publishSelection,%%00010                function () {%%00010                    if (_value.options.publishSelection != this.checked) {%%00010                        _value.options.publishSelection = this.checked;%%00010                        publishSelection(this.checked);%%00010                    }%%00010                });%%00010            knimeService.addMenuItem('Publish selection:', publishSelectionIcon, publishSelectionMenu);%%00010        }%%00010        %%00010        if (displayClearButton &amp;&amp;  _representation.options.enableSelection) {%%00010%%00009%%00009%%00009knimeService.addButton(&quot;clearSelectionButton&quot;, &quot;minus-square-o&quot;, &quot;Clear selection&quot;, function(){%%00010%%00009%%00009%%00009%%00009d3.selectAll(&quot;.row&quot;).classed({&quot;selected&quot;: false, &quot;knime-selected&quot;: false, &quot;unselected&quot;: false });%%00010%%00009%%00009%%00009%%00009removeHilightBar(&quot;&quot;,true);%%00010%%00009%%00009%%00009%%00009_value.options['selection'] = [];%%00010%%00009%%00009%%00009%%00009publishSelection(true);%%00010%%00009%%00009%%00009});%%00010%%00009%%00009%%00009d3.select(&quot;#clearSelectionButton&quot;).classed(&quot;inactive&quot;, true);%%00010%%00009%%00009}%%00010    };%%00010%%00010    function setCssClasses() {%%00010        // axis%%00010        var axis = d3.selectAll('.nv-axis')%%00010            .classed('knime-axis', true);%%00010        d3.selectAll('.nv-x')%%00010            .classed('knime-x', true);%%00010        d3.selectAll('.nv-y')%%00010            .classed('knime-y', true);%%00010        d3.selectAll('.nv-axislabel')%%00010            .classed('knime-axis-label', true);%%00010        axis.selectAll('path.domain')%%00010            .classed('knime-axis-line', true);%%00010        var axisMaxMin = d3.selectAll('.nv-axisMaxMin')%%00010            .classed('knime-axis-max-min', true);%%00010        axisMaxMin.selectAll('text')%%00010            .classed('knime-tick-label', true);%%00010        var tick = axis.selectAll('.knime-axis .tick')%%00010            .classed('knime-tick', true);%%00010        tick.selectAll('text')%%00010            .classed('knime-tick-label', true);%%00010        tick.selectAll('line')%%00010            .classed('knime-tick-line', true);%%00010%%00010        // legend%%00010        d3.selectAll('.nv-legendWrap')%%00010            .classed('knime-legend', true);%%00010        d3.selectAll('.nv-legend-symbol')%%00010            .classed('knime-legend-symbol', true);%%00010        d3.selectAll('.nv-legend-text')%%00010            .classed('knime-legend-label', true);%%00010%%00010        // Tooltip for axis labels allows to receive all mouse events%%00010        var axisToolTip = svg.selectAll('.knime-tick-label');%%00010        var labelToolTip = svg.selectAll('.knime-axis-label');%%00010        axisToolTip.style('pointer-events', 'all');%%00010        labelToolTip.style('pointer-events', 'all');%%00010        updateLabels();%%00010        if(_representation.options['enableSelection']) {%%00010        %%00009registerClickHandler();%%00010        }%%00010    }%%00010%%00010    function setTooltipCssClasses() {%%00010        // tooltip%%00010        var tooltip = d3.selectAll('.nvtooltip')%%00010            .classed('knime-tooltip', true);%%00010        tooltip.selectAll('.x-value')%%00010            .classed('knime-tooltip-caption', true)%%00010            .classed('knime-x', true);%%00010        tooltip.selectAll('.legend-color-guide')%%00010            .classed('knime-tooltip-color', true);%%00010        tooltip.selectAll('.key')%%00010            .classed('knime-tooltip-key', true);%%00010        tooltip.selectAll('.value')%%00010            .classed('knime-tooltip-value', true);%%00010%%00010    }%%00010%%00010    barchart.validate = function () {%%00010        return true;%%00010    };%%00010%%00010    barchart.getComponentValue = function () {%%00010        return _value;%%00010    };%%00010%%00010    barchart.getSVG = function () {%%00010        var svgElement = d3.select('svg')[0][0];%%00010        knimeService.inlineSvgStyles(svgElement);%%00010%%00010        // Return the SVG as a string.%%00010        return (new XMLSerializer()).serializeToString(svgElement);%%00010    };%%00010%%00010    return barchart;%%00010}());"/>
</config>
<config key="cssCode">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="/* make sure colors on bars are correct (inherit from group) */%%00010svg.colored .nvd3 .nv-multibar .nv-groups rect, %%00010svg.colored .nvd3 .nv-multibarHorizontal .nv-groups rect, %%00010svg.colored .nvd3 .nv-discretebar .nv-groups rect {%%00010%%00009fill: inherit !important;%%00010%%00009stroke: inherit !important;%%00010}%%00010%%00010text.knime-tick-label.knime-selected {%%00010%%00009font-weight: bold;%%00010}%%00010rect.knime-selected {%%00010%%00009fill: orange;%%00010%%00009%%00010}%%00010rect.knime-partially-selected {%%00010%%00009fill: grey;%%00010}%%00010text.knime-tick-label.knime-partially-selected {%%00010%%00009font-weight: bold;%%00010}%%00010%%00010rect.nv-bar.positive {%%00010%%00009cursor:pointer;%%00010}%%00010%%00010/* don't display the maximum grid line if present on vertical bar chart */%%00010/*.nv-multiBarWithLegend .knime-axis.knime-y g.tick.knime-tick:nth-last-child(3) line {%%00010    display: none;%%00010}*/"/>
</config>
<config key="jsDependencies">
<entry key="numSettings" type="xint" value="2"/>
<config key="dependency_0">
<entry key="name" type="xstring" value="nvd3"/>
<entry key="path" type="xstring" value="js-lib/nvd3/1.8.6/nv.d3.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="nv"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="D3_3.5.5"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_1">
<entry key="name" type="xstring" value="D3_3.5.5"/>
<entry key="path" type="xstring" value="js-lib/d3/d3.v3_5_5.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" isnull="true" value=""/>
<config key="dependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
</config>
<config key="cssDependencies">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="js-lib/nvd3/1.8.6/nv.d3.min.css"/>
</config>
<entry key="new" type="xboolean" value="false"/>
<entry key="inView" type="xboolean" value="true"/>
<config key="tableIds">
<entry key="array-size" type="xint" value="2"/>
<entry key="0" type="xstring" value="5172ad45-6683-4c0e-b375-dfef5b0b8495"/>
<entry key="1" type="xstring" isnull="true" value=""/>
</config>
<config key="variables">
<entry key="numSettings" type="xint" value="1"/>
<entry key="mapClass" type="xstring" value="string"/>
<entry key="key_0" type="xstring" value="knime.workspace"/>
<entry key="class_0" type="xstring" value="java.lang.String"/>
<entry key="value_0" type="xstring" value="C:\Users\sam\knime-workspace"/>
</config>
<config key="binaryFiles">
<entry key="numSettings" type="xint" value="0"/>
<entry key="mapClass" type="xstring" value="string"/>
</config>
<config key="options">
<entry key="numSettings" type="xint" value="22"/>
<entry key="mapClass" type="xstring" value="object"/>
<entry key="key_0" type="xstring" value="displayFullscreenButton"/>
<entry key="class_0" type="xstring" value="java.lang.Boolean"/>
<entry key="value_0" type="xboolean" value="true"/>
<entry key="key_1" type="xstring" value="displayClearSelectionButton"/>
<entry key="class_1" type="xstring" value="java.lang.Boolean"/>
<entry key="value_1" type="xboolean" value="true"/>
<entry key="key_2" type="xstring" value="svg"/>
<entry key="class_2" type="xstring" value="org.knime.dynamic.js.SettingsModelSVGOptions$JSONSVGOptions"/>
<config key="value_2">
<entry key="width" type="xint" value="800"/>
<entry key="height" type="xint" value="600"/>
<entry key="fullscreen" type="xboolean" value="true"/>
</config>
<entry key="key_3" type="xstring" value="legend"/>
<entry key="class_3" type="xstring" value="java.lang.Boolean"/>
<entry key="value_3" type="xboolean" value="true"/>
<entry key="key_4" type="xstring" value="enableHorizontalToggle"/>
<entry key="class_4" type="xstring" value="java.lang.Boolean"/>
<entry key="value_4" type="xboolean" value="true"/>
<entry key="key_5" type="xstring" value="freq"/>
<entry key="class_5" type="xstring" value="[Ljava.lang.String;"/>
<config key="value_5">
<entry key="array-size" type="xint" value="2"/>
<entry key="0" type="xstring" value="Mean"/>
<entry key="1" type="xstring" value="Std. Deviation"/>
</config>
<entry key="key_6" type="xstring" value="tooltip"/>
<entry key="class_6" type="xstring" value="java.lang.Boolean"/>
<entry key="value_6" type="xboolean" value="true"/>
<entry key="key_7" type="xstring" value="enableTitleEdit"/>
<entry key="class_7" type="xstring" value="java.lang.Boolean"/>
<entry key="value_7" type="xboolean" value="true"/>
<entry key="key_8" type="xstring" value="enableSelection"/>
<entry key="class_8" type="xstring" value="java.lang.Boolean"/>
<entry key="value_8" type="xboolean" value="true"/>
<entry key="key_9" type="xstring" value="sort"/>
<entry key="class_9" type="xstring" value="java.lang.Boolean"/>
<entry key="value_9" type="xboolean" value="false"/>
<entry key="key_10" type="xstring" value="enableSwitchMissValCat"/>
<entry key="class_10" type="xstring" value="java.lang.Boolean"/>
<entry key="value_10" type="xboolean" value="true"/>
<entry key="key_11" type="xstring" value="enableStackedEdit"/>
<entry key="class_11" type="xstring" value="java.lang.Boolean"/>
<entry key="value_11" type="xboolean" value="true"/>
<entry key="key_12" type="xstring" value="enableAxisEdit"/>
<entry key="class_12" type="xstring" value="java.lang.Boolean"/>
<entry key="value_12" type="xboolean" value="true"/>
<entry key="key_13" type="xstring" value="processInMemory"/>
<entry key="class_13" type="xstring" value="java.lang.Boolean"/>
<entry key="value_13" type="xboolean" value="true"/>
<entry key="key_14" type="xstring" value="reportOnMissingValues"/>
<entry key="class_14" type="xstring" value="java.lang.Boolean"/>
<entry key="value_14" type="xboolean" value="true"/>
<entry key="key_15" type="xstring" value="cat"/>
<entry key="class_15" type="xstring" value="java.lang.String"/>
<entry key="value_15" type="xstring" value="Iteration"/>
<entry key="key_16" type="xstring" value="enableStaggerToggle"/>
<entry key="class_16" type="xstring" value="java.lang.Boolean"/>
<entry key="value_16" type="xboolean" value="true"/>
<entry key="key_17" type="xstring" value="enableViewControls"/>
<entry key="class_17" type="xstring" value="java.lang.Boolean"/>
<entry key="value_17" type="xboolean" value="true"/>
<entry key="key_18" type="xstring" value="showWarnings"/>
<entry key="class_18" type="xstring" value="java.lang.Boolean"/>
<entry key="value_18" type="xboolean" value="true"/>
<entry key="key_19" type="xstring" value="enableSubtitleEdit"/>
<entry key="class_19" type="xstring" value="java.lang.Boolean"/>
<entry key="value_19" type="xboolean" value="true"/>
<entry key="key_20" type="xstring" value="aggr"/>
<entry key="class_20" type="xstring" value="java.lang.String"/>
<entry key="value_20" type="xstring" value="Sum"/>
<entry key="key_21" type="xstring" value="enableMaximumValue"/>
<entry key="class_21" type="xstring" value="java.lang.Boolean"/>
<entry key="value_21" type="xboolean" value="true"/>
</config>
<config key="inObjects">
<entry key="numSettings" type="xint" value="2"/>
<config key="inObject_0">
<entry key="className" type="xstring" value="org.knime.dynamic.js.base.grouped.GroupedProcessor$GroupingResult"/>
<entry key="jsonValue" type="xstring" value="{&quot;table&quot;:{&quot;@class&quot;:&quot;org.knime.js.core.JSONDataTable&quot;,&quot;id&quot;:&quot;603dfd4f-7936-4473-90e4-9371c9c12e85&quot;,&quot;extensions&quot;:null,&quot;rows&quot;:[{&quot;data&quot;:[&quot;100&quot;,0.985,0.009723266443504684],&quot;rowKey&quot;:&quot;Row0&quot;},{&quot;data&quot;:[&quot;101&quot;,0.989010989010989,0.006175291065373817],&quot;rowKey&quot;:&quot;Row1&quot;},{&quot;data&quot;:[&quot;102&quot;,0.9978260869565218,0.00446077544384852],&quot;rowKey&quot;:&quot;Row2&quot;},{&quot;data&quot;:[&quot;103&quot;,0.99247311827957,0.011087048202600399],&quot;rowKey&quot;:&quot;Row3&quot;},{&quot;data&quot;:[&quot;104&quot;,0.9797872340425532,0.005877726079288119],&quot;rowKey&quot;:&quot;Row4&quot;},{&quot;data&quot;:[&quot;105&quot;,0.976842105263158,0.007324761830931153],&quot;rowKey&quot;:&quot;Row5&quot;},{&quot;data&quot;:[&quot;106&quot;,0.9953124999999999,0.0063000554044718654],&quot;rowKey&quot;:&quot;Row6&quot;},{&quot;data&quot;:[&quot;107&quot;,0.9788659793814433,0.00973724991121994],&quot;rowKey&quot;:&quot;Row7&quot;},{&quot;data&quot;:[&quot;108&quot;,0.9801020408163266,0.005208344750347364],&quot;rowKey&quot;:&quot;Row8&quot;},{&quot;data&quot;:[&quot;109&quot;,0.9838383838383838,0.008914948991495832],&quot;rowKey&quot;:&quot;Row9&quot;},{&quot;data&quot;:[&quot;110&quot;,0.990909090909091,0.011770579851044034],&quot;rowKey&quot;:&quot;Row10&quot;}],&quot;spec&quot;:{&quot;@class&quot;:&quot;org.knime.js.core.JSONDataTableSpec&quot;,&quot;numRows&quot;:11,&quot;possibleValues&quot;:[[&quot;100&quot;,&quot;101&quot;,&quot;102&quot;,&quot;103&quot;,&quot;104&quot;,&quot;105&quot;,&quot;106&quot;,&quot;107&quot;,&quot;108&quot;,&quot;109&quot;,&quot;110&quot;],null,null],&quot;colNames&quot;:[&quot;Iteration&quot;,&quot;Mean&quot;,&quot;Std. Deviation&quot;],&quot;rowColorValues&quot;:[&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;],&quot;containsMissingValues&quot;:[false,false,false],&quot;minValues&quot;:[&quot;100&quot;,0.976842105263158,0.00446077544384852],&quot;hiddenColumns&quot;:[],&quot;maxValues&quot;:[&quot;110&quot;,0.9978260869565218,0.011770579851044034],&quot;filterIds&quot;:[null,null,null],&quot;rowSizeValues&quot;:null,&quot;colorModels&quot;:[],&quot;colTypes&quot;:[&quot;string&quot;,&quot;number&quot;,&quot;number&quot;],&quot;knimeTypes&quot;:[&quot;String&quot;,&quot;Number (double)&quot;,&quot;Number (double)&quot;],&quot;extensionTypes&quot;:[],&quot;extensionNames&quot;:[],&quot;numColumns&quot;:3,&quot;numExtensions&quot;:0},&quot;dataHash&quot;:null},&quot;uuid&quot;:&quot;51701408-db76-4102-9951-5878161961ac&quot;,&quot;translator&quot;:{&quot;mapping&quot;:{&quot;Row0&quot;:[&quot;Row0&quot;],&quot;Row1&quot;:[&quot;Row2&quot;],&quot;Row8&quot;:[&quot;Row16&quot;],&quot;Row9&quot;:[&quot;Row18&quot;],&quot;Row6&quot;:[&quot;Row12&quot;],&quot;Row7&quot;:[&quot;Row14&quot;],&quot;Row4&quot;:[&quot;Row8&quot;],&quot;Row5&quot;:[&quot;Row10&quot;],&quot;Row2&quot;:[&quot;Row4&quot;],&quot;Row10&quot;:[&quot;Row20&quot;],&quot;Row3&quot;:[&quot;Row6&quot;]},&quot;sourceID&quot;:null,&quot;targetIDs&quot;:null,&quot;forward&quot;:false}}"/>
</config>
<config key="inObject_1">
<entry key="jsonValue" type="xstring" isnull="true" value=""/>
</config>
</config>
<entry key="warnMessage" type="xstring" value=""/>
<entry key="errorMessage" type="xstring" value=""/>
</config>
